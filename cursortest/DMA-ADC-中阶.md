# 写在开头

1. 

# 一、作业内容

1. 理解优先级穿透
2. 任务之间可能的跳步

# 二、知识学习

1. ## 信号量（semaphore）

   - 用于多线程同步和资源保护
   - 本质是特殊的队列，只有队列头部，没有环形存储区
   - 信号量分为二值信号量、计数型信号量、互斥信号量和递归互斥信号量

1. 二值信号量

- 常用于任务与任务、中断与任务之间的同步。例如当中断发生，就释放信号量，等待信号量的任务发现可以使用信号量就执行。
- 用于共享资源的管理，同时只能一个任务使用共享资源。
- API：`SemaphoreHandle_t xSemaphoreCreateBinary( void )`

1. 互斥量

- **不能用于****中断服务程序****，因为****互斥****可能会阻塞。**
- 具有**优先级****继承****机制**。
- API：`SemaphoreHandle_t xSemaphoreCreateMutex( void )`

与二值信号量的区别：互斥量更适合用于互斥，而二值信号量更适合于同步。

1. ## 任务通知

1. xTaskNotifyAndQuery(g_adc_handle,PRODUCED(w_ch),esetBits,&adc_evt_mask);

可以在通知g_adc_handle的同时，获取这个任务之前的通知值给adc_evt_mask。

```C
BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
        {
        ...
        
                        if( pulPreviousNotificationValue != NULL )
                        {
                                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
                        }
```

1. 等待消息通知，参数：入口/出口处要清除的**位**

   1. ```C
      BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
      ```

# 三、实验内容

代码：https://gitee.com/jingezhengaoxing/t714-f4-project.git

逻辑图：

暂时无法在飞书文档外展示此内容

暂时无法在飞书文档外展示此内容

业务内容：

1. DMA中断通知任务A产生了新的数据，并不告诉产生的数据在那个buffer
2. 任务A通知B哪个buffer产生了新的数据，这里需要定义一个记录哪个buffer有数据的flag
3. 任务A在开启下一次ADC_DMA之前，要确定：下一个buffer是否有数据还没被处理
4. 两个线程的消息交互（关键）

- **线程A消息内容：**
  - 正在处理的buffer
  - 由B告知
  - 由A根据B邮箱数据清除
- **线程B消息内容**
  - 被填充了数据的buffer
  - 由A告知
  - B消费后由B清除

# 四、面试问题准备

1. 互斥锁和二值信号量有什么区别？
   1.  **互斥锁**：
   2. 用于线程间资源的互斥访问。
   3. 互斥锁具有 **优先级****继承****机制**，当一个低优先级线程持有锁，而一个高优先级线程试图获取锁时，低优先级线程的优先级会被临时提高到高优先级线程的水平，以**避免优先级反转**问题。
   4. 通常由 **持有锁的线程** 来释放锁，确保锁的使用是线程安全的。
   5. 更适合实现线程间 **互斥**。
   6.  **二值****信号量**：
   7. 通常用于 **线程间的同步** 或简单的互斥。
   8. 不具备优先级继承机制，因此在高优先级线程等待信号量时，低优先级线程可能会被其他更高优先级的线程抢占，从而延迟高优先级线程的执行。
   9. 任何线程都可以释放信号量。
   10. 更适合实现线程间的 **同步**。
   11. 
2. 是否可以用二值信号量来做线程A和线程B之间的buffer访问的同步？互斥锁和二值信号量的区别是什么？
   1.  可以，但是如果使用二值信号量，当A无buffer可以用，而线程B又被其他高优先级的任务抢先，那A的实时性就得不到保障。但是如果使用互斥锁，就可以临时提高B优先级，使其尽快执行。
   2.  **是否可以用二值****信号量****？**
   3. **可以**，二值信号量可以用于同步线程A和线程B的 buffer 访问，但二值信号量无法防止优先级反转问题。
   4. 如果线程A因 buffer 满而阻塞，线程B正在消费 buffer，但被其他高优先级任务抢占，线程A的实时性就会受到影响。
   5.  **互斥锁****的优势：**
   6. 如果使用互斥锁，当线程A试图获取互斥锁时，线程B的优先级会临时提高到线程A的优先级（优先级继承），从而保证线程B尽快完成消费，释放锁给线程A，确保实时性。
   7.  **总结：**
   8. 如果系统没有实时性要求，可以使用二值信号量。
   9. 如果需要实时性保障（比如嵌入式实时系统中），推荐使用互斥锁。

1. 如果线程A在获取互斥锁之前，不queue_peek检查线程B的邮箱接收队列是否邮箱被取走，会发什么可能的情况？

   1.  邮箱B中的消息代表还没被消费的数据buffer序号，A不查看的话可能会直接将这些buffer设置为下一次DMA的buffer目标地址，从而覆盖B还未来得及消费的buffer。
   2. 

2. 如果线程B不先使用queue peek去检查邮箱接收队列，直接使用queue receive去接收，然后去取互斥锁，将可能出现什么漏掉数据的情况？

   1.  因为线程A也会查看B的邮箱确定数据有没有被消费，如果发现没有数据，A会认为已经被消费，会使新的数据覆盖旧数据，但此时B可能还没消费完旧数据。造成数据访问不互斥。
   2.  保证数据访问互斥的关键：X线程访问**开始前就要保护**起来（使用二值信号量等方法），在**完全访问完之后再释放**对其的使用权。
   3. 线程B应先使用 `queue_peek` 检查队列状态，确保数据已经被接收并且消费前后是一致的。
   4. 获取互斥锁后再进行消费操作，这样可以防止线程A误判 buffer 的状态。

3. 是否可以想出一种不使用互斥锁也能实现同步和数据不冲突的方案？同时也能应用到共享Mmoy来实现零拷贝？

   1.  **可以，方案如下：**

   2.  **基本思路：**

   3. 使用双缓冲或循环缓冲区。

   4. 通过 **标志位机制** 来实现线程间的同步。

   5. 避免拷贝操作，直接在共享内存中使用标志位（例如生产状态、消费状态）。

   6.  **方案设计：**

   7. **双缓冲区的标志位管理：**

      - 每个缓冲区有两个标志位：
        - **生产标志位**：标记数据是否已被生产。
        - **消费标志位**：标记数据是否已被消费。

   8. **线程A（生产者）逻辑：**

      - 检查缓冲区的生产标志位，确保缓冲区未满。
      - 写入数据后，设置生产标志位。
      - 通知线程B数据已生产。

   9. **线程B（消费者）逻辑：**

      - 检查缓冲区的生产标志位，确保缓冲区有数据可消费。
      - 读取数据后，清除生产标志位，并设置消费标志位。
      - 通知线程A缓冲区已被消费。

   10. **代码示例：**

   11. ```C
       // 生产者线程A逻辑
       if (buffer_status[buffer_id].produced == 0) {  // 检查生产标志位
           // 写入数据到 buffer
           buffer_status[buffer_id].produced = 1;    // 设置生产标志位
           buffer_status[buffer_id].consumed = 0;    // 清除消费标志位
           notify_thread_b();  // 通知消费者线程
       }
       
       // 消费者线程B逻辑
       if (buffer_status[buffer_id].produced == 1) {  // 检查生产标志位
           // 读取数据
           buffer_status[buffer_id].produced = 0;    // 清除生产标志位
           buffer_status[buffer_id].consumed = 1;    // 设置消费标志位
           notify_thread_a();  // 通知生产者线程
       }
       ```

   12.  **方案特点：**

   13. **同步方式：**

       1. 通过标志位实现同步，无需互斥锁或信号量。

   14. **支持****共享内存****和****零拷贝****：**

       1. 数据直接在共享内存中操作，避免了数据拷贝。

   15. **限制：**

       1. 如果使用单缓冲区，需要额外的逻辑避免覆盖。
       2. 推荐使用双缓冲或循环缓冲区。

1. ADC中阶应用场景是什么？

1.添加互斥锁后的ADC中阶具有优先级穿透的功能，这里加互斥锁是因为一般靠近中断的线程A优先级都比较高，但是由A通知解包的线程B的优先级往往在优先级规划中设计起来较为复杂，高或者低都不好。我们使用互斥锁，就能在运行过程中利用系统的优先级继承机制（互斥锁有优先级继承的能力)，这样线程B的优先级就不用再去复杂的规划了。

2.即使我们使用了优先级规划，但不排除，还有可能存在其他更高优先级的线程，或者线程A迅速再次产生了ADC中断，会让线程B在收到消息后，还没有机会开始拿互斥锁，线程A又开始尝试拿互斥锁，那这时候线程B就跳步了(B线程没有处理数据，结果线程A就切换了buffer)。

问题

这里取非的话，不就成了0xff吗？buffer[0xff]作为DMA的目标地址不对吧？不应该是+1并模buffer总数吗

![img](https://ncnoby04sj0b.feishu.cn/space/api/box/stream/download/asynccode/?code=NDA5ZDlmZDlmNjM4ZmM1NDdlMDQwYmU1OWExMDVjMzdfMlBGNVlkTVd1bmpQczlnc2hZNUc1YTFSVGVaRjNSbWJfVG9rZW46SXZMcGI3ckhob3hHQTh4VVFlc2NSd0dIbmliXzE3NDA0MDk3NjE6MTc0MDQxMzM2MV9WNA)